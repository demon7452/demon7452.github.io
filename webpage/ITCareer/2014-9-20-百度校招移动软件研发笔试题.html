---
layout: default2
title: 我的Blog
---
<h1 align="center">百度2015校园招聘---移动软件研发工程师笔试题</h1>

<h2>一、简答题</h2>
<h4>1、简述linux进程间通信的几种方式。</h4>
<pre size="15px">进程间通讯
       进程间通信就是不同进程之间传播或交换信息，进程的用户空间是互相独立的，进程之间可以利用系统空间交换信息。

管道(pipe)
       管道是一种半双工的通信方式，数据只能单向流动。如果要进行双工通信，需要建立两个管道。
       管道只能在具有亲缘关系的进程间使用，例如父子进程或兄弟进程。

有名管道(named pipe)
       有名管道也是双半工的通信方式，但它允许无亲缘关系的进程间使用。

信号量(semophore)
       信号量常用来作为一种锁机制来使用，它是一个记数器，用来控制多进程对共享资源的访问，防止多个进程同时访问一个共享资源。信号量主要
	   用作为进程间或同一进程间不同线程之间的同步手段。

信号(sinal)
        信号是一种比较复杂的通信方式，用于通知接收进程某些事件已经发生，要注意信号处理中调用的函数是否为信号安全。

消息队列(message queue)
       消息队列是由消息的链表组成，存放在内核中并由消息队列标识符标识。

共享内存(shared memory)
       共享内存就是映射一段被其他进程所访问的内存，这段共享内存由一个进程创建，可由多个进程访问。共享内存是最快的IPC方式，它是针对其
	   他进程间通信方式的低运行效率而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

套接字(socket)
       套接字也是进程间通信的一种方式，与其他方式不同的是，它可以用在不同主机间的进程通信（也是它的主要用途）。


几种方式的缺点
        管道：          速度慢，容量有限，只能用于亲缘关系进程间通信。
        有名管道：   同管道，不过允许无亲缘关系进程间通信。
        消息队列：   容量受系统限制，队列中会遗留数据，读时要考虑到这些未读完的数据。
        信号量：      主要用于同步，无法传递复杂的数据信息。
        共享内存：   最快IPC方式，但要注意同步的问题，相当于把任务交给了开发者。</pre>
<h4>2、typedef char *String_t;和 #define String_d char* 这两句在使用上有什么区别？</h4>
<pre>答：typedef char *String_t 定义了一个新的类型别名，有类型检查。而#define String_d char * 
只是做了个简单的替换，无类型检查，前者在编译的时候处理，后者在预编译的时候处理。  
同时定义多个变量的时候有区别，主要区别在于这种使用方式String_t  a,b;  String_d  c,d;    a,b ,c都是char*类型，而d为char类型  
由于typedef还要做类型检查。。#define没有。。所以typedef比#define安全。。</pre>
<h4>3、请描述下TCP和UDP的差别，并采用三次握手机制建立TCP链接的三个步骤。</h4>
<pre>
	TCP---传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输
	数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
     UDP---用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保
	 证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。
	 
	UDP 与 TCP 的主要区别:
    
	UDP 不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP 在许多方面非常有效。
		当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。ICQ 短消息使用 UDP 
		协议发送消息。 
		许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。

    TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。
	TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。
	记住，较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。
	这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。
	为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。
	如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。
	
	TCP的三次握手协议：

	在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
	第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
	第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，
				 此时服务器进入SYN_RECV状态；
	第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，
				 客户端和服务器进入ESTABLISHED状态，完成三次握手。
	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	完成三次握手，客户端与服务器开始传送数据.
</pre>

<h2>二、程序设计题</h2>
<h4>1、输入一个表示整数的字符串，把该字符串转换成整数并输出，例如输入字符串"345",则输出整数345。给定函数原型</h4>
 <h4>int StrToInt(const char* str),完成字符串转换成整数的功能，不得用库函数atoi.</h4>
 <pre>
 题目：输入一个表示整数的字符串，把该字符串转换成整数并输出。例如输入字符串"345"，则输出整数345。分析：这道题尽管不是很难，学过C/C++语
言一般都能实现基本功能，但不同程序员就这道题写出的代码有很大区别，可以说这道题能够很好地反应出程序员的思维和编程习惯，因此已经被包括
微软在内的多家公司用作面试题。建议读者在往下看之前自己先编写代码，再比较自己写的代码和下面的参考代码有哪些不同。
首先我们分析如何完成基本功能，即如何把表示整数的字符串正确地转换成整数。还是以"345"作为例子。当我们扫描到字符串的第一个字符'3'时，我
们不知道后面还有多少位，仅仅知道这是第一位，因此此时得到的数字是3。当扫描到第二个数字'4'时，此时我们已经知道前面已经一个3了，再在后面
加上一个数字4，那前面的3相当于30，因此得到的数字是3*10+4=34。接着我们又扫描到字符'5'，我们已经知道了'5'的前面已经有了34，由于后面要加
上一个5，前面的34就相当于340了，因此得到的数字就是34*10+5=345。
分析到这里，我们不能得出一个转换的思路：每扫描到一个字符，我们把在之前得到的数字乘以10再加上当前字符表示的数字。这个思路用循环不难实
现。
由于整数可能不仅仅之含有数字，还有可能以'+'或者'-'开头，表示整数的正负。因此我们需要把这个字符串的第一个字符做特殊处理。如果第一个字
符是'+'号，则不需要做任何操作；如果第一个字符是'-'号，则表明这个整数是个负数，在最后的时候我们要把得到的数值变成负数。
接着我们试着处理非法输入。由于输入的是指针，在使用指针之前，我们要做的第一件是判断这个指针是不是为空。如果试着去访问空指针，将不可避
免地导致程序崩溃。另外，输入的字符串中可能含有不是数字的字符。每当碰到这些非法的字符，我们就没有必要再继续转换。最后一个需要考虑的问
题是溢出问题。由于输入的数字是以字符串的形式输入，因此有可能输入一个很大的数字转换之后会超过能够表示的最大的整数而溢出。
现在已经分析的差不多了，开始考虑编写代码。首先我们考虑如何声明这个函数。由于是把字符串转换成整数，很自然我们想到：
int StrToInt(const char* str);
这样声明看起来没有问题。但当输入的字符串是一个空指针或者含有非法的字符时，应该返回什么值呢？0怎么样？那怎么区分非法输入和字符串本身就
是”0”这两种情况呢？
接下来我们考虑另外一种思路。我们可以返回一个布尔值来指示输入是否有效，而把转换后的整数放到参数列表中以引用或者指针的形式传入。于是我
们就可以声明如下：
bool StrToInt(const char *str, int& num);
这种思路解决了前面的问题。但是这个函数的用户使用这个函数的时候会觉得不是很方便，因为他不能直接把得到的整数赋值给其他整形变脸，显得不
够直观。
前面的第一种声明就很直观。如何在保证直观的前提下当碰到非法输入的时候通知用户呢？一种解决方案就是定义一个全局变量，每当碰到非法输入的
时候，就标记该全局变量。用户在调用这个函数之后，就可以检验该全局变量来判断转换是不是成功。
下面我们写出完整的实现代码。参考代码：
enum Status {kValid = 0, kInvalid};
int g_nStatus = kValid;

///////////////////////////////////////////////////////////////////////
// Convert a string into an integer
///////////////////////////////////////////////////////////////////////
int StrToInt(constchar* str)
{
       g_nStatus = kInvalid;
      longlong num = 0;

      if(str != NULL)
       {
            constchar* digit = str;

            // the first char in the string maybe '+' or '-'
            bool minus = false;
            if(*digit == '+')
                   digit ++;
            elseif(*digit == '-')
             {
                   digit ++;
                   minus = true;
             }

            // the remaining chars in the string
            while(*digit != '/0')
             {
                  if(*digit >= '0' && *digit <= '9')
                   {
                         num = num * 10 + (*digit - '0');

                        // overflow  
                        if(num > std::numeric_limits<int>::max())
                         {
                               num = 0;
                               break;
                         }

                         digit ++;
                   }
                  // if the char is not a digit, invalid input
                  else
                   {
                         num = 0;
                        break;
                   }
             }

            if(*digit == '/0')
             {
                   g_nStatus = kValid;
                  if(minus)
                         num = 0 - num;
             }
       }

       returnstatic_cast<int>(num);
}

讨论：在参考代码中，我选用的是第一种声明方式。不过在面试时，我们可以选用任意一种声明方式进行实现。但当面试官问我们选择的理由时，我们
要对两者的优缺点进行评价。第一种声明方式对用户而言非常直观，但使用了全局变量，不够优雅；而第二种思路是用返回值来表明输入是否合法，在
很多API中都用这种方法，但该方法声明的函数使用起来不够直观。
最后值得一提的是，在C语言提供的库函数中，函数atoi能够把字符串转换整数。它的声明是int atoi(constchar 
*str)。该函数就是用一个全局变量来标志输入是否合法的。</pre>
<h4>2、判断一个单链表是否有环，若有，找出环的入口点。</h4>
<p>答案链接：<a href="http://blog.csdn.net/xudacheng06/article/details/7706245" target="_blank">http://blog.csdn.net/xudacheng06/article/details/7706245</a></p>
<pre>判断链表是否存在环，有如下几种解法：
1. 遍历链表，将已经遍历过的节点放在一个hash表中，如果一个节点已经存在hash表中，说明有环。时间:O(n) 空间:O(n)
2. 反转链表。 时间O(n)，空间O(1)，使用三个指针。（ref:  http://www.cppblog.com/tx7do/archive/2009/01/06/71280.html）
    单链表反转：下面给出两种可能的实现。
    普通版：

void reverse(node*& head)  
{  
    if ( (head == 0) || (head->next == 0) ) return;// 边界检测  
    node* pNext = 0;  
    node* pPrev = head;// 保存链表头节点  
    node* pCur = head->next;// 获取当前节点  
    while (pCur != 0)  
    {  
        pNext = pCur->next;// 将下一个节点保存下来  
        pCur->next = pPrev;// 将当前节点的下一节点置为前节点  
        pPrev = pCur;// 将当前节点保存为前一节点  
        pCur = pNext;// 将当前节点置为下一节点  
    }  
    head->next = NULL;  
    head = pPrev;  
	p;
}  
    递归版：

node* reverse( node* pNode, node*& head)  
{  
    if ( (pNode == 0) || (pNode->next == 0) ) // 递归跳出条件  
    {  
        head = pNode; // 将链表切断，否则会形成回环  
        return pNode;  
    }  
  
    node* temp = reserve(pNode->next, head);// 递归  
    temp->next = pNode;// 将下一节点置为当前节点，既前置节点  
    return pNode;// 返回当前节点  
}  
      使用反转链表的方法, 每过一个节点就把该节点的指针反向。若存在环，反转next指针最终会走到链表头部。若没有环，反转next指针会破坏链表结构(使链表反向), 所以为还原链表，需要把链表再反向一次。 这种方法的空间复杂度是O(1), 实事上我们使用了3个额外指针;而时间复杂度是O(n), 我们最多2次遍历整个链表(当链表中没有环的时候)。下面给出一个实现，但最大的问题是：若存在环，则无法还原到链表的原状态。

bool reverse(Node *head) {  
 Node *curr = head;  
 Node *next = head->next;  
 curr->next = NULL;  
  
 while(next!=NULL) {  
  if(next == head) { /* go back to the head of the list, so there is a loop */  
    next->next = curr;  
    return true;  
  }  
  
  Node *temp = curr;  
  curr = next;  
  next = next->next;  
  curr->next = temp;  
 }  
  
 /* at the end of list, so there is no loop, let's reverse the list back */  
 next = curr->next;  
 curr ->next = NULL;  
 while(next!=NULL) {  
  Node *temp = curr;  
  curr = next;  
  next = next->next;  
  curr->next = temp;  
 }  
  
 return false;  
}  



3. 快慢指针。 时间O(n)，空间O(1)，使用两个指针。（ref: http://blog.csdn.net/mingming_bupt/article/details/6331333）
    判断环的存在：设置两个指针(fast, slow)，初始值都指向头，slow每次前进一步，fast每次前进二步。如果链表存在环，则fast必定先进入环，而slow后进入环，两个指针必定相遇。(当然，fast先行头到尾部为NULL，则是无环链表)。
[cpp] view plaincopyprint?
bool IsExitsLoop(slist * head)  
{  
slist * slow = head , * fast = head;  
  
while ( fast && fast -> next )  
{  
slow = slow -> next;  
fast = fast -> next -> next;  
if ( slow == fast ) break ;  
}  
  
return ! (fast == NULL || fast -> next == NULL);  
}   
    寻找环的入口点： 当fast按照每次2步，slow每次一步的方式走，发现fast和slow重合，确定了单向链表有环路。
	接下来，让fast回到链表的头部，重新走，每次步长1，那么当fast和slow再次相遇的时候，就是环路的入口了。
	证明：在fast和slow第一次相遇的时候，假定slow走了n步，环路的入口是在p步，那么
           slow走的路径： p+c ＝ n； c为fast和slow相交点 距离环路入口的距离
           fast走的路径： p+c+k*L = 2*n； L为环路的周长，k是整数
          显然，如果从p+c点开始，slow再走n步的话，还可以回到p+c这个点。
          同时，fast从头开始走，步长为1，经过n步，也会达到p+c这点。
          显然，在这个过程中fast和slow只有前p步骤走的路径不同。所以当p1和p2再次重合的时候，必然是在链表的环路入口点上。
[cpp] view plaincopyprint?
slist * FindLoopPort(slist * head)  
{  
slist * slow = head, * fast = head;  
  
while ( fast && fast -> next )  
{  
slow = slow -> next;  
fast = fast -> next -> next;  
if ( slow == fast ) break ;  
}  
  
if (fast == NULL || fast -> next == NULL)  
return NULL;  
  
slow = head;  
while (slow != fast)  
{  
slow = slow -> next;  
fast = fast -> next;  
}  
  
return slow;  
}  
</pre>
<h4>3、求子数组的最大和。条件：输入一个整型数组，数组里有正数也有负数，数组中连续的一个或多个整数组成一个子数</h4>
<h4>组，每个字数组都有一个和。求所有字数组和的最大值。要求时间复杂度为O(n).例如输入数组1，-2，3，10，-4，7，2</h4>
<h4>，-5。最大字数组为3，10，-4，7，2。因此输出为该字数组的和18.</h4>
<p>答案链接：<a href="http://blog.csdn.net/werocpp/article/details/6250695" target="_blank">http://blog.csdn.net/werocpp/article/details/6250695</a></p>
 <pre>/********************************************************************
   3.求子数组的最大和
   题目：
   输入一个整形数组，数组里有正数也有负数。
   数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。
   求所有子数组的和的最大值。要求时间复杂度为O(n)。

   例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2，
   因此输出为该子数组的和18。
*********************************************************************/
/********************************************************************
	问题描述符合动态规划最优子结构的要求。
	关键在于转换为求出以每一个元素结尾的和最大子数组的问题求解。

	设b[i]表示以a[i]结尾的子数组的最大子段和，即：
	b[i]=max{sum(a[j~k])},其中0<=j<=i，j<=k<=i。
	因此对于数组a[0~n]的最大字段和为max{b[i]}，其中0<=i<n。

	在计算b[i]时，可以考虑以下三种情况：
	1，b[i] = b[i-1]+a[i]，当b[i-1]>0时，这时候的b[i]中包含a[i]。
	2，b[i] = a[i]，当b[i-1]<=0，这时候以a[i]重新作为b[i]的起点。
	3，b[i]不包含a[i]的情况，这种情况在计算b[i]之前已经计算处结果，保存在b[0~i-1]中。最后计算max{b[i]}时会考虑到。

	b[i] = max{b[i-1]+a[i]，a[i]}。

	而数组a[0~n]则为max{b[i]}。在实现时，可以省略数组b[i]。
*********************************************************************/
bool SAMV_GetSubArraySumMax(const int *pDataArray, int nArraySize, int *pSubArrayMaxSum, int *pSubArrayBeginIndex, int *pSubArrayEndIndex)
{
	// 参数有效性
	if (pDataArray == NULL || nArraySize<=0)
	{
		return false;
	}
	
	// 临时变量
	int bi_1 = pDataArray[0];    // 记录a0-ai_1形成的和最大自数组的和值
	int maxbi = pDataArray[0];   // 记录bi_1的最大值
	int subBeginIndex = 0;
	int subEndIndex = 0;
	int maxSubBeginIndex = 0;
	int maxSubEndIndex = 0;

	// 求解
	for (int i=1; i<nArraySize; i++)
	{
		// 求得以a[i]结尾的和最大子数组值
		if (bi_1 > 0)
		{
			bi_1 += pDataArray[i];
			subEndIndex = i;
		}
		else
		{
			bi_1 = pDataArray[i];
			subBeginIndex = i;
			subEndIndex = i;
		}		

		// 求所有自数组中和最大值
		if (maxbi < bi_1)
		{
			maxbi = bi_1;
			maxSubBeginIndex = subBeginIndex;
			maxSubEndIndex = subEndIndex;
		}
	}

	// 得到输出参数
	if (pSubArrayMaxSum != NULL)
	{
		*pSubArrayMaxSum = maxbi;
	}
	if (pSubArrayBeginIndex != NULL)
	{
		*pSubArrayBeginIndex = maxSubBeginIndex;
	}
	if (pSubArrayEndIndex != NULL)
	{
		*pSubArrayEndIndex = maxSubEndIndex;
	}
	
	return true;
}</pre>
<h2>三、系统设计题</h2>
	<h4>设计一个服务调度管理器，服务器接收数据包，数据包大小为32个字节。第一个字节是请求的请求的优先级，后面31</h4>
<h4>个字节是请求的命令，服务器根据客户端发来的命令，分配资源，完成相应的服务，然后将操作的结果返回给客户端，但</h4>
<h4>由于服务器资源有限，服务器可以存储操作的结果，如果下次有同样的命令到来的时候，直接获取操作结果返回给客户端即可。</h4>
<h4>要求设计一个服务器调度管理器，满足以下调度条件：</h4>
<h4><1>同样条件下，请求次数多的请求首先获得服务，请求次数最大为255；</h4>
<h4><2>同样条件下，请求优先级高的请求首先获得服务，优先级最高为16；</h4>
<h4>要做的是：</h4>
<h4><1>设计服务器的核心调度算法</h4>
<h4><2>数据结构设计</h4>
<h4><3>如果服务器的记录容量是20万条，分心需要占用多大的内存空间。</h4>
 <pre></pre>