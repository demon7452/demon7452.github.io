---
layout: post
title: JVM Collections
category: Interview
tags: JVM
keywords: Java面试题
description: JVM 相关学习总结
---

# JVM 学习总结

## Java运行时数据区
<br>
![1](/public/img/jvm/javaRuntimeDataArea.png)

- 程序计数器 Program Counter Register
- 虚拟机栈 Virtual Machine Stacks
<br>
![1](/public/img/jvm/javaVirtualMachineStacks.png)
> 虚拟机栈也是线程私有，而且生命周期与线程相同，每个Java方法在执行的时候都会创建一个栈帧（Stack Frame）用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息
- 本地方法栈 Native Method Stacks
> 本地方法栈为虚拟机使用到本地方法服务。
- Java堆 Heap
> 对大多数应用来说，Java堆（Heap）是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。该内存区域唯一的目的就是存放对象实例，Java对象实例以及数组都在堆上分配（随着JIT编译器发展等技术成熟，所有对象分配在堆上也渐渐不是那么“绝对”了）。
 <br>Java堆是垃圾收集器管理的主要区域，因此Java堆也常被称为“GC堆”，由于现在收集器基于分代收集算法，Java堆还可以细分为：新生代和老年代。
- 方法区 Method Area
> 方法区与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 运行时常量池 Runtime Constant Pool
> 运行时常量池是方法区的一部分，Class文件中除了有关类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
  <br>运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并非不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量池放入池中。
- 直接内存 Direct Memory
> 使用Native函数库直接分配的堆外内存，避免在Java堆和Native堆中来回复制数据。
<br>忽略直接内存，会导致各个内存区域总和大于物理内存。

## 对象已死么
- 引用计数法 Reference Counting
> 难以解决对象之间的相互引用问题。
- 可达性分析 Accessibility Analysis
> 起始点GC Roots；搜索走过的路径称为引用链(Reference Chain)

## GC Roots 对象
- 虚拟机栈(栈帧中本地变量表)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI(Native方法)引用的对象

## 引用 Reference 
> 4种引用强度依次减弱， Strong > Soft > Weak > Phantom
- 强引用 Strong Reference

> 只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用 Soft Reference

> 用来描述一些还有用非必要的对象，在将要发生内存溢出之前，将会把这些对象列入范围进入二次回收。
- 弱引用 Weak Reference

> 用来描述非必须对象，被弱引用关联的对象只能生存到下次垃圾回收之前。
- 虚引用 Phantom Reference

> 虚引用对原对象没有任何影响，也无法通过虚引用获得一个对象实例。
<br>设置虚引用的唯一目的就是对象被垃圾回收时收到一个系统通知。

## finalize
> 真正宣告一个对象死亡，至少需要经过两次标记过程。<br> finalize方法只会被系统调用一次。

![1](/public/img/jvm/finalize.png)

