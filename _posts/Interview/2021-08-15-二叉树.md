---
layout: post
title: 二叉树
category: Interview
tags: tree
keywords: Java面试题 二叉树
description: 二叉树
---
> 来源：二叉树前序、中序、后序遍历相互求法  链接: https://blog.csdn.net/u011068702/article/details/51914220
> 来源：Leetcode 二叉树  链接: https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe17x7/

## 二叉树定义
### 前序遍历:
    首先访问根节点，然后遍历左子树，最后遍历右子树。
### 中序遍历:
    是先遍历左子树，然后访问根节点，然后遍历右子树。
### 后序遍历:
    是先遍历左子树，然后遍历右子树，最后访问树的根节点。
## 前序、中序、后序遍历相互求法

<p>首先&#xff0c;我们看看前序、中序、后序遍历的特性&#xff1a; <br /> 前序遍历&#xff1a; <br />     1.访问根节点 <br />     2.前序遍历左子树 <br />     3.前序遍历右子树 <br /> 中序遍历&#xff1a; <br />     1.中序遍历左子树 <br />     2.访问根节点 <br />     3.中序遍历右子树 <br /> 后序遍历&#xff1a; <br />     1.后序遍历左子树 <br />     2.后序遍历右子树 <br />     3.访问根节点</p> 
<p><strong>一、已知前序、中序遍历&#xff0c;求后序遍历</strong></p> 
<p>例&#xff1a;</p> 
<p>前序遍历:         GDAFEMHZ</p> 
<p>中序遍历:         ADEFGHMZ</p> 
<p><strong>画树求法&#xff1a;<br /> </strong>第一步&#xff0c;根据前序遍历的特点&#xff0c;我们知道根结点为G</p> 
<p>第二步&#xff0c;观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树&#xff0c;G右侧的HMZ必然是root的右子树。</p> 
<p> 第三步&#xff0c;观察左子树ADEF&#xff0c;左子树的中的根节点必然是大树的root的leftchild。在前序遍历中&#xff0c;大树的root的leftchild位于root之后&#xff0c;所以左子树的根节点为D。</p> 
<p>第四步&#xff0c;同样的道理&#xff0c;root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中&#xff0c;一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树&#xff0c;并且遍历的左子树的第一个节点就是左子树的根节点。同理&#xff0c;遍历的右子树的第一个节点就是右子树的根节点。</p> 
<p>第五步&#xff0c;观察发现&#xff0c;上面的过程是递归的。先找到当前树的根节点&#xff0c;然后划分为左子树&#xff0c;右子树&#xff0c;然后进入左子树重复上面的过程&#xff0c;然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下&#xff1a;</p> 
<p>1 确定根,确定左子树&#xff0c;确定右子树。</p> 
<p>2 在左子树中递归。</p> 
<p>3 在右子树中递归。</p> 
<p>4 打印当前根。</p> 
<p>那么&#xff0c;我们可以画出这个二叉树的形状&#xff1a;</p> 
<p><img src="https://img-blog.csdn.net/20160715012029772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA&#61;&#61;/dissolve/70/gravity/Center" width="auto" height="auto" alt="" /></p> 
<p>那么&#xff0c;根据后序的遍历规则&#xff0c;我们可以知道&#xff0c;后序遍历顺序为&#xff1a;AEFDHZMG</p> 

<p><strong>二、已知中序和后序遍历&#xff0c;求前序遍历</strong></p> 
<p>依然是上面的题&#xff0c;这次我们只给出中序和后序遍历&#xff1a;</p> 
<p>中序遍历:       ADEFGHMZ</p> 
<p>后序遍历:       AEFDHZMG</p> 
<p>画树求法&#xff1a;<br /> 第一步&#xff0c;根据后序遍历的特点&#xff0c;我们知道后序遍历最后一个结点即为根结点&#xff0c;即根结点为G。<br /> <br /> 第二步&#xff0c;观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树&#xff0c;G右侧的HMZ必然是root的右子树。<br /> <br /> 第三步&#xff0c;观察左子树ADEF&#xff0c;左子树的中的根节点必然是大树的root的leftchild。在前序遍历中&#xff0c;大树的root的leftchild位于root之后&#xff0c;所以左子树的根节点为D。<br /> <br /> 第四步&#xff0c;同样的道理&#xff0c;root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前后序遍历中&#xff0c;一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树&#xff0c;并且遍历的左子树的第一个节点就是左子树的根节点。同理&#xff0c;遍历的右子树的第一个节点就是右子树的根节点。<br /> <br /> 第五步&#xff0c;观察发现&#xff0c;上面的过程是递归的。先找到当前树的根节点&#xff0c;然后划分为左子树&#xff0c;右子树&#xff0c;然后进入左子树重复上面的过程&#xff0c;然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下&#xff1a;</p> 
<p>1 确定根,确定左子树&#xff0c;确定右子树。</p> 
<p>2 在左子树中递归。</p> 
<p>3 在右子树中递归。</p> 
<p>4 打印当前根。</p> 
<p>这样&#xff0c;我们就可以画出二叉树的形状&#xff0c;如上图所示&#xff0c;这里就不再赘述。</p> 
<p>那么&#xff0c;前序遍历:         GDAFEMHZ</p> 